using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace BlazorPathHelper;

/// <summary>

/// </summary>
[Generator]
public class BlazorPathHelperSourceGenerator : IIncrementalGenerator
{
    private const string ExportClassName = "PathHelper";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sourceRoot = context.SyntaxProvider.ForAttributeWithMetadataName(
            "BlazorPathHelper.BlazorPathAttribute",
            static (_, _) => true,
            static (context, _) => context);

        context.RegisterSourceOutput(sourceRoot, EmitPathRoot);
    }

    private static void EmitPathRoot(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var symbol = (INamedTypeSymbol)source.TargetSymbol;
        var rootAttribute = symbol.GetAttributes()
            .First(a => a.AttributeClass?.Name == nameof(BlazorPathAttribute));
        var rootAttr = MapToType<BlazorPathAttribute>(rootAttribute);
        

        // extract "const string" fields
        var fields = symbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => f.IsConst && f.Type.SpecialType == SpecialType.System_String)
            .ToArray();

        var builders = fields
            .Select(field =>
            {
                // if has [BlazorPathItem] attribute, use it
                var pathItemAttrData = field.GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.Name == nameof(BlazorPathItemAttribute));
                var pathItemAttr = pathItemAttrData != null
                    ? MapToType<BlazorPathItemAttribute>(pathItemAttrData)
                    : null;
                var pathRawValue = (string)field.ConstantValue!;
                var variableName = field.Name;
                return new PathAttributeParser(variableName, pathRawValue, pathItemAttr);
            })
            .ToList();

        var accessbility = symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.Internal => "internal",
            _ => "internal"
        };
        var namespaceName = rootAttr.Namespace ?? symbol.ContainingNamespace.ToDisplayString();
        var exportClassName = rootAttr.ClassName ?? symbol.Name;
        var code = FinallyBuildCode(builders, symbol, accessbility, namespaceName, exportClassName);
        ExportCodeFile(context, symbol, code);
        ExportBlazorMenuCode(builders.ToArray(), context, symbol, accessbility, namespaceName, exportClassName);
    }

    private static string FinallyBuildCode(
        IEnumerable<PathAttributeParser> builders, ISymbol symbol,
        string accessbility, string namespaceName, string exportClassName)
    {
        // TODO: exportClassNameを省略できるように
        // TODO: Helperの名前を変更できるように
        var code = $$"""
         // <auto-generated />
         #nullable enable
         #pragma warning disable CS8600
         #pragma warning disable CS8601
         #pragma warning disable CS8602
         #pragma warning disable CS8603
         #pragma warning disable CS8604

         using System;

         namespace {{namespaceName}};

         {{accessbility}} partial class {{exportClassName}}
         {
             public static class Helper
             {
                 {{string.Join("\n        ", builders.SelectMany(b => b.Builders))}}
             }
         }
         """;
        return code;
    }

    private static void ExportBlazorMenuCode(
        PathAttributeParser[] builders, SourceProductionContext context, ISymbol symbol,
        string accessbility, string namespaceName, string exportClassName)
    {
        var buildersToMenu = builders.Where(b => b.IsDisplayMenu).ToArray();
        var rootItems = buildersToMenu.Where(b => b.IsRootMenuItem);
        var treeStructures = rootItems.Select(rootItem
            => new PathAttributeTreeParser(buildersToMenu, rootItem));

        var fullType = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        var variableName = symbol.Name;
        // TODO: exportClassNameを省略できるように
        // TODO: MenuItemの名前を変更できるように
        var totalCode = $$"""
         // <auto-generated />
         #nullable enable
         using System;
         using System.Collections.Generic;
         using BlazorPathHelper;

         namespace {{namespaceName}};
         
         {{accessbility}} partial class {{exportClassName}}
         {
             public static readonly BlazorPathMenuItem[] MenuItem = [
                 {{string.Join(",\n        ", treeStructures.Select((t,i) => t.ExportCode(i,0)))}}
             ];
         }
         """;
        context.AddSource($"BlazorPathHelper_Menu_{fullType}.g.cs", totalCode);

    }

    private static void ExportCodeFile(SourceProductionContext context, ISymbol symbol, string code)
    {
        var fullType = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
        context.AddSource($"BlazorPathHelper_{fullType}.g.cs", code);
    }

    private static PathBuilderArg GeneratePathBuilderArg(string variable, string typeString, bool isNullable)
    {
        var csharpType = typeString switch
        {
            "datetime" => nameof(DateTime),
            "guid" => nameof(Guid),
            "nonfile" => "string",
            "" => "string",
            null => "string",
            _ => typeString
        };
        return new PathBuilderArg(variable, csharpType, isNullable);
    }

    private class PathAttributeTreeParser
    {
        public int Index { get; set; }
        public string GroupPath { get; set; }
        public PathAttributeParser Parser { get; set; }
        public PathAttributeTreeParser[] ChildItems { get; set; }

        public PathAttributeTreeParser(PathAttributeParser[] parsers, PathAttributeParser rootItem)
        {
            // 自分のパスが親のパスを含むものを抽出する。
            // 末尾/は削除しておく。
            var trimmedPath = rootItem.PathRawValue.TrimEnd('/');
            var subMenu = parsers
                .Where(p => p.GroupPath == trimmedPath && !p.IsRootMenuItem)
                .Select(p => new PathAttributeTreeParser(parsers, p));
            this.Index = Array.IndexOf(parsers, rootItem);
            this.GroupPath = trimmedPath;
            this.Parser = rootItem;
            this.ChildItems = subMenu.ToArray();
        }

        public string ExportCode(int groupIndex, int groupLevel)
        {
            // TODO: インデントをきっちり出力
            var code = $$"""
                     new BlazorPathMenuItem(){ 
                        Index = {{Index}},
                        GroupKey = "{{Parser.GroupPath}}",
                        GroupIndex = {{groupIndex}},
                        GroupLevel = {{groupLevel}},
                        Name = "{{Parser.DisplayName}}",
                        Path = "{{Parser.PathRawValue}}",
                        Icon = "{{Parser.MenuIcon}}",
                        Children = [{{string.Join(",\n", ChildItems.Select((c,i) => c.ExportCode(i, groupLevel+1)))}}]
                     }
                     """;
            // trim linebreak and spaces
            return code.Replace("\n", "").Replace("  ", "");
        }
    }

    private class PathAttributeParser
    {
        public PathAttributeParser(
            string variableName, string pathRawValue,
            BlazorPathItemAttribute? pathItemAttr = null)
        {
            List<PathBuilderArg> csharpDefinitions = [];
            // https://regex101.com/r/HcMv3Z/1
            var pathRegex = new Regex(@"{([^\/\\:?]+)(:([^\/\\:?]+))?(\?)?}");
            var matches = pathRegex.Matches(pathRawValue);
            // ReSharper disable once LoopCanBeConvertedToQuery
            foreach (Match match in matches)
            {
                var variable = match.Groups[1].Value;
                var typeString = match.Groups.Count > 3 ? match.Groups[3].Value : "";
                var isNullable = match.Groups.Count > 4 && match.Groups[4].Value == "?";
                var csharpDefinition = GeneratePathBuilderArg(variable, typeString, isNullable);
                csharpDefinitions.Add(csharpDefinition);
            }
            VariableName = variableName;
            PathRawValue = pathRawValue;
            Args = csharpDefinitions;

            // 表示名は指定があればそれを使う。なければ変数名を使う。
            DisplayName = pathItemAttr?.Name ?? variableName;
            GroupPath = pathItemAttr?.Group ?? BuildDefaultGroupMenuPath(pathRawValue);
            MenuIcon = pathItemAttr?.Icon;
            // 表示するかどうかは引数がないかどうかで判断する。
            IsDisplayMenu = pathItemAttr?.Visible ?? !IsRequireArgs;
            // ルートメニューかどうかは指定があればそれを使う。
            IsRootMenuItem = pathItemAttr?.RootForce == true || (GroupPath == "");
        }

        internal string PathRawValue { get; private set; }
        private string VariableName { get; set; }
        private List<PathBuilderArg> Args { get; set; }

        internal string? DisplayName { get; private set; }
        internal string GroupPath { get; private set; }
        internal string? MenuIcon { get; private set; }
        internal bool IsDisplayMenu { get; private set; }
        internal bool IsRootMenuItem { get; private set; }

        private bool IsRequireArgs => Args.Count > 0;

        internal string[] Builders =>
        [
            $"/// <summary>Build Path String: {PathRawValue} </summary>",
            $"public static string {VariableName}({BuilderArgs}) => {BuilderFunction};"
        ];

        private string BuilderFunction => IsRequireArgs
            ? $"string.Format(\"{PathFormatStringBase}\", {BuilderVals})"
            : $"\"{PathRawValue}\"";
        private string BuilderArgs => string.Join(", ", Args.Select(a => a.ArgDefinition));
        private string BuilderVals => string.Join(", ", Args.Select(a => a.Variable));
        private string PathFormatStringBase
        {
            get
            {
                var count = 0;
                return Regex.Replace(PathRawValue, @"{[^}]+}", (_) => $"{{{count++}}}");
            }
        }

        private string BuildDefaultGroupMenuPath(string path)
        {
            // 基本的にはパスの親ディレクトリをキーにすればいい。
            // ただし、変数が入っている場合は変数部分を取り除いた一番上をキーにする。
            // すなわち、 `{`がある → その前まで。 `{`がない → `/`でsplitして最後の要素を消す。
            // e.g. / -> ""
            // e.g. /sample -> ""
            // e.g. /sample/hoge -> /sample
            // e.g. /sample/{value} -> /sample
            // e.g. /sample/{val1}/{val2} -> /sample
            if (path.Contains('{'))
            {
                return path.Substring(0, path.IndexOf('{'));
            }
            else
            {
                var split = path.Split('/');
                return string.Join("/", split.Take(split.Length - 1));
            }
        }
    }

    private class PathBuilderArg(string variable, string type, bool isNullable)
    {
        internal string ArgDefinition => $"{type}{NullChar} {variable}{(isNullable ? " = null" : "")}";
        private string NullChar => isNullable ? "?" : "";
        internal string Variable => (type == nameof(DateTime))
            ? $"{variable}.ToString(\"yyyy-MM-ddTHH:mm:ss\")"
            : variable;
    }

    // thanks https://stackoverflow.com/questions/67539903
    private static T MapToType<T>(AttributeData attributeData) where T : Attribute
    {
        T attribute;
        if (attributeData.AttributeConstructor != null && attributeData.ConstructorArguments.Length > 0)
        {
            attribute = (T)Activator.CreateInstance(typeof(T), GetActualConstuctorParams(attributeData).ToArray());
        }
        else
        {
            attribute = (T)Activator.CreateInstance(typeof(T));
        }
        foreach (var p in attributeData.NamedArguments)
        {
            typeof(T).GetProperty(p.Key)!.SetValue(attribute, p.Value.Value);
        }
        return attribute;
    }

    // thanks https://stackoverflow.com/questions/67539903
    private static IEnumerable<object> GetActualConstuctorParams(AttributeData attributeData)
    {
        foreach (var arg in attributeData.ConstructorArguments)
        {
            if (arg.Kind == TypedConstantKind.Array)
            {
                // Assume they are strings, but the array that we get from this
                // should actually be of type of the objects within it, be it strings or ints
                // This is definitely possible with reflection, I just don't know how exactly. 
                yield return arg.Values.Select(a => a.Value).OfType<string>().ToArray();
            }
            else
            {
                yield return arg.Value!;
            }
        }
    }
}



