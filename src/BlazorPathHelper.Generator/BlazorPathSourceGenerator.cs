using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection.Metadata;
using BlazorPathHelper.CodeBuilders;
using BlazorPathHelper.Models;
using BlazorPathHelper.Utils;
using Microsoft.CodeAnalysis;

#pragma warning disable CS1591

namespace BlazorPathHelper;

[Generator]
public class BlazorPathHelperSourceGenerator : IIncrementalGenerator
{
    // ReSharper disable once InconsistentNaming
    private static readonly string NL = RoslynGeneratorUtilities.GetNewLine();

    // Initialize is called at startup to configure the generator
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // parse .razor files
        // The pages to be generated may not exist when the source generator is running
        // (The timing of execution is simultaneous and cannot interfere with each other )
        // Therefore, when the source generator is executed, it is necessary to obtain information directly from the .razor file
        // ref: https://github.com/dotnet/roslyn/issues/57239
        var razorFileStructures = ParseRazorStructureFactory.ParseRazorFiles(context);

        // extract BlazorPathAttribute and combine with razorFileStructures
        var sourceRoot = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                "BlazorPathHelper.BlazorPathAttribute",
                static (_, _) => true,
                static (context, _) => context
            )
            .Combine(razorFileStructures);

        // register source output
        context.RegisterSourceOutput(sourceRoot, EmitPathRoot);
    }

    private static void EmitPathRoot(
        SourceProductionContext context,
        (
            GeneratorAttributeSyntaxContext source,
            ImmutableArray<ParseRazorStructure> structures
        ) pairs
    )
    {
        var (source, structures) = pairs;
        var symbol = (INamedTypeSymbol)source.TargetSymbol;
        var parseRecords = ParseRecordFactory.GenerateRecordsFromPathAttr(symbol);
        var treeStructures = ParseRecordTreeStructureFactory.Create(parseRecords);
        ExportBuilderCode(context, parseRecords);
        ExportMenuStructureCode(context, treeStructures);
        ExportRazorClassCode(context, parseRecords, structures);
    }

    private static void ExportBuilderCode(
        SourceProductionContext context,
        List<ParseRecord> records
    )
    {
        var no = 0;
        var recordsGroupBy = records.GroupBy(r => new { r.ExportClassName, r.Namespace });
        foreach (var recordsOfCls in recordsGroupBy)
        {
            no++;
            var fr = recordsOfCls.First();
            var exportNamespace = fr.Namespace is not null ? $"namespace {fr.Namespace};" : "";
            var builderCodes = recordsOfCls.SelectMany(r =>
            {
                var builder = new ParseRecordToPathHelper(new ()
                {
                    IsIgnore = r.IsIgnore,
                    IsExistQuery = r.IsExistQuery,
                    IsRequireArgs = r.IsRequireArgs,
                    PathRawValue = r.PathRawValue,
                    VariableName = r.VariableName,
                    Parameters = r.Parameters,
                    QueryTypeSymbol = r.QueryTypeSymbol,
                    QueryRecords = r.QueryRecords,
                });
                return builder.BuildPathHelpers();
            });
            var code = $$"""
                // <auto-generated />
                #nullable enable
                #pragma warning disable CS8600
                #pragma warning disable CS8601
                #pragma warning disable CS8602
                #pragma warning disable CS8603
                #pragma warning disable CS8604
                using System;
                using static BlazorPathHelper.BlazorPathHelperUtility;

                {{exportNamespace}}

                {{fr.AccessModifier}} partial class {{fr.ExportClassName}}
                {
                    /// <summary>
                    /// Helper class for path building
                    /// </summary>
                    public static partial class Helper
                    {
                        {{string.Join($"{NL}        ", builderCodes)}}
                    }
                }
                """;
            context.AddSource($"BPH_{fr.ExportClassName}_{no:D4}_Builder.g.cs", code);
        }
    }

    private static void ExportMenuStructureCode(
        SourceProductionContext context,
        List<ParseRecordTreeStructure> treeRecords
    )
    {
        var no = 0;
        var recordsGroupBy = treeRecords.GroupBy(r => new
        {
            r.Record.ExportClassName,
            r.Record.Namespace,
        });
        foreach (var recordsOfCls in recordsGroupBy)
        {
            no++;
            var fr = recordsOfCls.First().Record;
            var menuCodes = recordsOfCls.Select(
                (t, i) =>
                {
                    var builder = new ParseRecordTreeToMenuItems(t);
                    return builder.ExportMenuCode(i, 0);
                }
            );
            var exportNamespace = fr.Namespace is not null ? $"namespace {fr.Namespace};" : "";
            var code = $$"""
                // <auto-generated />
                #nullable enable
                #pragma warning disable CS8600
                #pragma warning disable CS8601
                #pragma warning disable CS8602
                #pragma warning disable CS8603
                #pragma warning disable CS8604
                using System;
                using System.Collections.Generic;
                using BlazorPathHelper;

                {{exportNamespace}}

                {{fr.AccessModifier}} partial class {{fr.ExportClassName}}
                {
                    /// <summary>
                    /// Generated menu item from path definition (flattened)
                    /// </summary>
                    public static BlazorPathMenuItem[] MenuItemFlatten => MenuItem.ToFlatten(i => i.Children);
                    /// <summary>
                    /// Generated menu item from path definition (tree structure)
                    /// </summary>
                    public static readonly BlazorPathMenuItem[] MenuItem = [
                {{string.Join($",{NL}", menuCodes)}}
                    ];
                }
                """;
            context.AddSource($"BPH_{fr.ExportClassName}_{no:D4}_Menu.g.cs", code);
        }
    }

    /// <summary>
    /// Generates Razor class code for valid page records and adds the generated source to the production context.
    /// </summary>
    /// <remarks>
    /// Iterates over parse records with a non-null page type and constructs a partial class definition with a route derived from the record's path (excluding the path base).
    /// The generated class includes namespace, parameter, and query code segments assembled from the provided Razor structures. If a namespace ambiguity is detected during generation, a diagnostic error is reported.
    /// </remarks>
    /// <param name="context">The source production context used to add the generated Razor class source.</param>
    /// <param name="records">List of parsed records containing Razor page attribute data; only records with a valid page type are processed.</param>
    /// <param name="structures">Immutable array of parsed Razor structures providing additional context needed for code generation.</param>
    private static void ExportRazorClassCode(
        SourceProductionContext context,
        List<ParseRecord> records,
        ImmutableArray<ParseRazorStructure> structures
    )
    {
        var no = 0;
        var targetRecords = records.Where(r => r.PageTypeSymbol != null);
        foreach (var record in targetRecords)
        {
            no++;
            try
            {
                var builder = new ParseRecordToRazorCls(record, structures);
                var pageClassName = builder.PageClassName;
                var exportNamespace = builder.ExportNamespaceCode();
                var parameterCodes = builder.ExportParametersCode();
                var queryCodes = builder.ExportQueryCode();
                var exportCodes = parameterCodes.Concat(queryCodes);
                var code = $$"""
                    // <auto-generated />
                    #nullable enable
                    #pragma warning disable CS8600
                    #pragma warning disable CS8601
                    #pragma warning disable CS8602
                    #pragma warning disable CS8603
                    #pragma warning disable CS8604
                    using Microsoft.AspNetCore.Components;

                    {{exportNamespace}}

                    // @page "{{record.PathRawValueWithoutPathBase}}"
                    [Route("{{record.PathRawValueWithoutPathBase}}")]
                    {{record.AccessModifier}} partial class {{pageClassName}}
                    {
                        {{string.Join($"{NL}    ", exportCodes)}}
                    }
                    """;
                context.AddSource($"BPH_{pageClassName}_{no:D4}_RazorClass.g.cs", code);
            }
            catch (NamespaceAmbiguousException e)
            {
                var diagnostic = Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "BPH0001",
                        title: "Namespace is Ambiguous",
                        messageFormat: "Namespace is Ambiguous: {0}",
                        category: "BlazorPathHelper",
                        defaultSeverity: DiagnosticSeverity.Error,
                        isEnabledByDefault: true,
                        helpLinkUri: "https://github.com/arika0093/BlazorPathHelper/issues/12"
                    ),
                    record.PageAttributeLocation,
                    e.Message
                );
                context.ReportDiagnostic(diagnostic);
            }
        }
    }
}
