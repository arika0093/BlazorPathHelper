### 最小限的使用方法

以下是最小限必要的内容：

* 准备一个带有 `#!csharp [BlazorPath]` 属性的类。在定义类时，需要使用 `#!csharp partial` 属性。
* 在该类中定义一个 `#!csharp const string` 类型的常量作为成员。
* 为成员添加 `#!csharp [Query<QueryClass>]` 属性。

在生成URL构建函数的过程中，会根据 `#!csharp [Query<QueryClass>]` 的定义生成支持查询的函数。

```csharp title="WebPaths.cs"
[BlazorPath]
public partial class WebPaths
{
  [Query<QueryRecord>]
  public const string CounterWithQuery = "/counter/query";
}

public record QueryRecord(string query = "hello", int page = 0, bool? opt = null);
```

!!! warning "注意！"

    `QueryRecord` 类必须写在 `.cs` 文件中。
    由于 SourceGenerator 的限制，不能写在 `.razor` 文件中。

!!! note "建议：明确参数的初始值"

    建议为每个参数指定默认值或将其设为可空。（需要考虑到查询参数未指定时的情况）

??? abstract "生成的代码"

    ```csharp title="Auto Generated Code"
    // <auto-generated />
    public partial class WebPaths
    {
      public partial class Helper
      {
        public static string CounterWithQuery(QueryRecord __query)
          => string.Format("/counter/query{0}", BuildQuery([
            ToEscapedStrings("query", __query.query),
            ToEscapedStrings("page", __query.page),
            ToEscapedStrings("opt", __query.opt)
          ]));
      }
    }
    ```

### 工作原理

为带有 `#!csharp [Query<QueryClass>]` 属性的成员生成以下函数：

```csharp title="Auto Generated Code"
public static string CounterWithQuery(QueryRecord __query)
  => string.Format("/counter/query{0}", BuildQuery([
    ToEscapedStrings("query", __query.query),
    ToEscapedStrings("page", __query.page),
    ToEscapedStrings("opt", __query.opt)
  ]));
```

从上面的生成代码可以看出，`QueryRecord` 类的每个属性都被展开为查询参数。
在生成此函数时，BlazorPathHelper 内部执行以下操作：

1. 检查是否附加了 `#!csharp [Page<QueryClass>]` 属性。
2. 如果指定了，则提取 `QueryClass` 中定义的属性。
    - 成员也可以使用，但不推荐。
3. 对每个属性调用 `ToEscapedStrings` 函数生成查询参数。
    - 例如，上述情况下，会生成 `#!csharp "query=hello"`, `#!csharp "page=0"`, `#!csharp "opt=true"` 这样的字符串。
4. 将生成的查询参数传递给 `BuildQuery` 函数生成查询字符串。
    - 上述情况下，会生成 `#!csharp "?query=hello&page=0&opt=true"` 这样的字符串。
    - 例如 `opt=null` 时，会变成 `#!csharp "?query=hello&page=0"`，`opt` 参数不会输出。

!!! tip "不支持嵌套属性"

    如上定义，实际上并不是恢复整个类，而是提取属性。
    因此，目前不支持嵌套属性。

### 更改查询名称

指定 `#!csharp [Query<QueryRecord>]` 属性时，查询名称直接使用 `QueryRecord` 的属性名。
如果想更改查询名称，请添加 `#!csharp [SupplyParameterFromQuery(Name = "shortName")]` 属性。（与传统指定方法相同）

```csharp title="WebPaths.cs"
public record QueryRecord
{
    [SupplyParameterFromQuery(Name = "short")]
    public required string SuperLongName { get; set; }
}

[BlazorPath]
public partial class WebPaths
{
    [Query<QueryRecord>]
    public const string QueryTest = "/query-test";
      // -> /query-test?short=hello
}
```

### 支持的类型

`QueryClass` 的属性可以定义如下：

#### 常规类型

| 类定义示例                                   | 输出的查询URL示例                 |
| ---------------------------------------- | ----------------------------- |
| `#!csharp record QueryClass(int val1)`   | `#!csharp "/?val1=5"`         |
| `#!csharp record QueryClass(bool? flg1)` | `#!csharp "/?flg1=true", "/"` |

除此之外，只要实现了 `#!csharp ToString()` 且 Blazor 能够恢复的类型，基本上都支持。

#### 数组

| 类定义示例                                   | 输出的查询URL示例                 |
| ---------------------------------------- | ----------------------------- |
| `#!csharp record QueryClass(string[] arr)`   | `#!csharp "/?arr=foo&arr=bar&arr=buz"`|

除了 `#!csharp string[]`，`#!csharp int[]` 和 `#!csharp bool[]` 等也支持。
由于 Blazor 不支持 `IEnumerable` 和 `List`，因此不支持这些类型。